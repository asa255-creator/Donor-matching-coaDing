/** CONFIG **/
const CANDIDATE_SHEET = 'Candidates';     // A: FirstName, B: LastName, C: Multiplier
const ORG_SHEET       = 'Organizations';  // A: OrganizationName, B: Multiplier
const OPTIONS_SHEET   = 'Options';        // A2:E2 values
const OUTPUT_SHEET    = 'KREF_Exports';
const USER_AGENT      = 'Mozilla/5.0 (Apps Script)';
const EXPORT_BASE     = 'https://secure.kentucky.gov/kref/publicsearch/ExportContributors';

/** DIAGNOSTIC FUNCTION - Test KREF connectivity **/
function testKrefConnection() {
  const ui = SpreadsheetApp.getUi();

  // Test 1: Simple URL fetch
  const testUrl = 'https://secure.kentucky.gov/kref/publicsearch/';
  Logger.log('Testing connection to: ' + testUrl);

  try {
    const response = UrlFetchApp.fetch(testUrl, {
      method: 'get',
      headers: { 'User-Agent': USER_AGENT },
      muteHttpExceptions: true,
      followRedirects: true,
      validateHttpsCertificates: true
    });

    const code = response.getResponseCode();
    Logger.log(`Response code: ${code}`);

    if (code >= 200 && code < 300) {
      ui.alert('âœ“ Connection Test Passed',
               `Successfully connected to KREF site.\nHTTP ${code}\n\nThe site is reachable.`,
               ui.ButtonSet.OK);
    } else {
      const preview = response.getContentText().substring(0, 300);
      ui.alert('âš  HTTP Error',
               `Got HTTP ${code} from KREF site.\n\nResponse preview:\n${preview}`,
               ui.ButtonSet.OK);
    }

    // Test 2: Try an actual export URL with minimal parameters
    const opts = readOptions_();
    const testExportUrl = buildExportUrl_({
      ContributionSearchType: 'Candidate',
      CandidateFirstName: 'Test',
      CandidateLastName: 'Test',
      MinAmount: 1,
      MaxAmount: 250,
      MinimalDate: toKrefDate_(opts.minimalDate),
      ContributionTypes: 'INDIVIDUAL'
    });

    Logger.log('Testing export URL: ' + testExportUrl);
    const exportResponse = UrlFetchApp.fetch(testExportUrl, {
      method: 'get',
      headers: {
        'User-Agent': USER_AGENT,
        'Accept': 'text/csv,text/plain,*/*'
      },
      muteHttpExceptions: true
    });

    const exportCode = exportResponse.getResponseCode();
    Logger.log(`Export response code: ${exportCode}`);
    const exportText = exportResponse.getContentText();
    Logger.log(`Export response length: ${exportText.length} chars`);

    if (exportCode >= 200 && exportCode < 300) {
      ui.alert('âœ“ Export Test Passed',
               `Successfully fetched export data.\nHTTP ${exportCode}\nReceived ${exportText.length} characters`,
               ui.ButtonSet.OK);
    } else {
      ui.alert('âš  Export Failed',
               `HTTP ${exportCode} from export endpoint.\n\nResponse:\n${exportText.substring(0, 500)}`,
               ui.ButtonSet.OK);
    }

  } catch (e) {
    Logger.log('Connection test failed: ' + e.toString());
    Logger.log('Error stack: ' + e.stack);

    ui.alert('âŒ Connection Failed',
             `Could not connect to KREF site.\n\nError: ${e.message}\n\n` +
             `This could mean:\n` +
             `â€¢ Kentucky.gov is blocking Apps Script\n` +
             `â€¢ The site is down\n` +
             `â€¢ Network/DNS issues\n` +
             `â€¢ SSL certificate problems\n\n` +
             `Check View â†’ Logs for details.`,
             ui.ButtonSet.OK);
  }
}

// Output columns
// A Recipient
// B DonorFirst
// C DonorLast
// D Address1
// E Address2
// F City
// G State
// H Zip
// I Amount
// J WeightedAmount
// K ReceiptDate
// L Occupation
// M Employer
// N DonationID
const OUTPUT_HEADER = [
  'Recipient','DonorFirst','DonorLast','Address1','Address2','City','State','Zip',
  'Amount','WeightedAmount','ReceiptDate','Occupation','Employer','DonationID'
];

const DEFAULTS = {
  minAmount: 1,
  maxAmount: 249,
  minimalDate: '2018-07-01',
  maximalDate: '',
  contributionTypes: 'INDIVIDUAL'
};

/** MAIN **/
function exportAllToSheet() {
  const ss = SpreadsheetApp.getActive();

  // Always start clean and write header
  const out = resetOutputSheet_(ss, OUTPUT_SHEET);

  const opts = readOptions_();
  const candRows = readRows_(ss, CANDIDATE_SHEET, 2, 1, 3).filter(r => r[0] && r[1]); // [First, Last, Multiplier]
  const orgRows  = readRows_(ss, ORG_SHEET, 2, 1, 2).filter(r => r[0]);               // [OrgName, Multiplier]

  const total = candRows.length + orgRows.length;
  if (!total) {
    SpreadsheetApp.getUi().alert('No rows found in Candidates or Organizations.');
    return;
  }

  let done = 0;
  showProgress_(done, total, 'Starting');

  // Candidates
  for (const [first, last, multRaw] of candRows) {
    const multiplier = toNumber_(multRaw, 1);
    const url = buildExportUrl_({
      ContributionSearchType: 'Candidate',
      CandidateFirstName: first,
      CandidateLastName: last,
      MinAmount: opts.minAmount,
      MaxAmount: opts.maxAmount,
      MinimalDate: toKrefDate_(opts.minimalDate),
      MaximalDate: opts.maximalDate ? toKrefDate_(opts.maximalDate) : '',
      ContributionTypes: opts.contributionTypes
    });
    appendReducedCsv_(url, out, multiplier);
    done++; showProgress_(done, total, `Candidate: ${first} ${last}`); Utilities.sleep(150);
  }

  // Organizations
  for (const [orgName, multRaw] of orgRows) {
    const multiplier = toNumber_(multRaw, 1);
    const url = buildExportUrl_({
      ContributionSearchType: 'Organization',
      OrganizationName: orgName,
      MinAmount: opts.minAmount,
      MaxAmount: opts.maxAmount,
      MinimalDate: toKrefDate_(opts.minimalDate),
      MaximalDate: opts.maximalDate ? toKrefDate_(opts.maximalDate) : '',
      ContributionTypes: opts.contributionTypes
    });
    appendReducedCsv_(url, out, multiplier);
    done++; showProgress_(done, total, `Organization: ${orgName}`); Utilities.sleep(150);
  }

  SpreadsheetApp.getActive().toast('100% â€¢ Done', 'KREF export', 5);
  SpreadsheetApp.getUi().alert('Done. Appended to KREF_Exports.');
}

/** CSV -> SELECTED COLUMNS ONLY, RECIPIENT FROM CSV **/
function appendReducedCsv_(url, outSheet, multiplier) {
  let csvText;
  try {
    csvText = httpGetText_(url);
  } catch (e) {
    Logger.log(`ERROR fetching URL: ${e.toString()}\nURL: ${url}`);
    // Don't throw - just skip this candidate/org and continue with others
    SpreadsheetApp.getActive().toast(`âš ï¸ Failed to fetch data: ${e.message}`, 'Error', 5);
    return;
  }
  if (!csvText) return;

  const rows = Utilities.parseCsv(csvText, ',') || [];
  if (!rows.length) return;

  const header = rows[0].map(h => String(h || '').trim().toLowerCase());
  const idx = {
    recipFirst: findCol_(header, ['recipient first name','recipient firstname','candidate first name']),
    recipLast:  findCol_(header, ['recipient last name','recipient lastname','candidate last name']),
    toOrg:      findCol_(header, ['to organization']),
    donorFirst: findCol_(header, ['contributor first name','contributor firstname','first name']),
    donorLast:  findCol_(header, ['contributor last name','contributor lastname','last name']),
    addr1:      findCol_(header, ['address 1','address1','address line 1']),
    addr2:      findCol_(header, ['address 2','address2','address line 2']),
    city:       findCol_(header, ['city']),
    state:      findCol_(header, ['state']),
    zip:        findCol_(header, ['zip','zip code','zipcode','postal code']),
    amount:     findCol_(header, ['amount','contribution amount']),
    receipt:    findCol_(header, ['receipt date','date received','transaction date']),
    occupation: findCol_(header, ['occupation']),
    employer:   findCol_(header, ['employer'])
  };

  const data = rows.slice(1);
  if (!data.length) return;

  // Read options here so we do not change the function signature
  const optsForDecay = readOptions_();
  const annualLoss = optsForDecay.percentLossPerYear; // 0..1

  const mapped = [];
  for (const r of data) {
    if (!r || !r.length) continue;

    const rf = capName_(safeGet_(r, idx.recipFirst));
    const rl = capName_(safeGet_(r, idx.recipLast));
    let recipient = (rf || rl) ? [rf, rl].filter(Boolean).join(' ') : '';
    if (!recipient) {
      const toOrg = safeGet_(r, idx.toOrg);
      if (toOrg) recipient = toOrg.trim();
    }

    const donorFirst = capName_(safeGet_(r, idx.donorFirst));
    const donorLast  = capName_(safeGet_(r, idx.donorLast));
    const amountStr  = safeGet_(r, idx.amount);
    const amountNum  = parseAmount_(amountStr);

    const receiptStr = safeGet_(r, idx.receipt);
    const decay      = computeAgeDecay_(receiptStr, annualLoss);

    const m          = toNumber_(multiplier, 1);
    const weighted   = Number.isFinite(amountNum) ? roundCents_(amountNum * m * decay) : '';

    const occupation = safeGet_(r, idx.occupation);
    const employer   = safeGet_(r, idx.employer);

    if (!recipient && !donorFirst && !donorLast && !amountStr && !receiptStr) continue;

    const rawState = safeGet_(r, idx.state);
    const rawZip = safeGet_(r, idx.zip);
    const validState = getValidState_(rawState, rawZip);

    mapped.push([
      recipient,                       // A Recipient
      donorFirst,                      // B DonorFirst
      donorLast,                       // C DonorLast
      safeGet_(r, idx.addr1),          // D Address1
      safeGet_(r, idx.addr2),          // E Address2
      safeGet_(r, idx.city),           // F City
      validState,                      // G State (validated or from ZIP lookup)
      normalizeZip_(rawZip),           // H Zip
      amountStr,                       // I Amount
      weighted,                        // J WeightedAmount
      receiptStr,                      // K ReceiptDate
      occupation,                      // L Occupation
      employer,                        // M Employer
      ''                               // N DonationID
    ]);
  }

  if (!mapped.length) return;

  const startRow = outSheet.getLastRow() + 1;
  const numCols  = OUTPUT_HEADER.length;
  outSheet.getRange(startRow, 1, mapped.length, numCols).setValues(mapped);

  const donationIdCol = 14; // N
  const nextIdStart = getNextDonationId_(outSheet, donationIdCol);
  const idValues = Array.from({ length: mapped.length }, (_, i) => [nextIdStart + i]);
  outSheet.getRange(startRow, donationIdCol, mapped.length, 1).setValues(idValues);
}


/** FEC LOCAL FILE UPLOAD (no Drive) **/
function addFecReportsFromComputer() {
  const html = HtmlService.createHtmlOutput(`
<!DOCTYPE html>
<html>
  <body style="font-family:sans-serif;padding:12px;">
    <h3>Add downloaded FEC reports</h3>
    <p>Select one or more CSV files from your computer.</p>
    <input type="file" id="files" accept=".csv" multiple />
    <br><br>
    <button id="upload">Add to FEC_Exports</button>
    <script>
      document.getElementById('upload').addEventListener('click', async () => {
        const input = document.getElementById('files');
        if (!input.files.length) { alert('No files selected'); return; }
        const payload = [];
        for (const f of input.files) {
          const text = await f.text();
          payload.push({ name: f.name, text });
        }
        google.script.run
          .withFailureHandler(err => { alert('Error: ' + err); })
          .withSuccessHandler(msg => { alert(msg); google.script.host.close(); })
          .appendUploadedFecCsvBatch(payload);
      });
    </script>
  </body>
</html>
  `).setWidth(420).setHeight(260);
  SpreadsheetApp.getUi().showModalDialog(html, 'Add FEC reports');
}

// Drag-and-drop upload dialog for FEC reports (modern UI)
function fec_uploadDialog() {
  const html = HtmlService.createHtmlOutput(fec_getUploadHtml_())
    .setWidth(520)
    .setHeight(340)
    .setTitle('Upload FEC Reports');
  SpreadsheetApp.getUi().showModalDialog(html, 'FEC Reports Upload');
}

function fec_getUploadHtml_() {
  return `
<!DOCTYPE html>
<html>
<head>
  <base target="_top">
  <style>
    body {
      font-family: Arial, sans-serif;
      padding: 20px;
      margin: 0;
    }
    #dropzone {
      border: 3px dashed #4285f4;
      border-radius: 8px;
      padding: 40px;
      text-align: center;
      background-color: #f8f9fa;
      transition: all 0.3s;
      cursor: pointer;
    }
    #dropzone.dragover {
      background-color: #e8f0fe;
      border-color: #1967d2;
    }
    #dropzone:hover {
      background-color: #e8f0fe;
    }
    .icon {
      font-size: 48px;
      color: #4285f4;
      margin-bottom: 10px;
    }
    .message {
      font-size: 16px;
      color: #5f6368;
      margin-bottom: 8px;
    }
    .hint {
      font-size: 12px;
      color: #80868b;
    }
    #fileList {
      margin-top: 15px;
      padding: 10px;
      background-color: #fff;
      border-radius: 4px;
      max-height: 100px;
      overflow-y: auto;
      display: none;
    }
    #fileList.visible {
      display: block;
      border: 1px solid #dadce0;
    }
    .file-item {
      padding: 4px 0;
      font-size: 13px;
      color: #5f6368;
    }
    #status {
      margin-top: 15px;
      padding: 10px;
      border-radius: 4px;
      display: none;
    }
    #status.success {
      background-color: #d4edda;
      color: #155724;
      border: 1px solid #c3e6cb;
      display: block;
    }
    #status.error {
      background-color: #f8d7da;
      color: #721c24;
      border: 1px solid #f5c6cb;
      display: block;
    }
    #status.processing {
      background-color: #fff3cd;
      color: #856404;
      border: 1px solid #ffeaa7;
      display: block;
    }
  </style>
</head>
<body>
  <div id="dropzone">
    <div class="icon">ðŸ“Š</div>
    <div class="message">Drag and drop FEC CSV files here</div>
    <div class="hint">or click to select files (multiple files supported)</div>
  </div>
  <input type="file" id="fileInput" accept=".csv" multiple style="display: none;">
  <div id="fileList"></div>
  <div id="status"></div>

  <script>
    const dropzone = document.getElementById('dropzone');
    const fileInput = document.getElementById('fileInput');
    const fileList = document.getElementById('fileList');
    const status = document.getElementById('status');
    let selectedFiles = [];

    // Click to select file
    dropzone.addEventListener('click', () => {
      fileInput.click();
    });

    // File selected via input
    fileInput.addEventListener('change', (e) => {
      if (e.target.files.length > 0) {
        handleFiles(Array.from(e.target.files));
      }
    });

    // Prevent default drag behaviors
    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
      dropzone.addEventListener(eventName, preventDefaults, false);
      document.body.addEventListener(eventName, preventDefaults, false);
    });

    function preventDefaults(e) {
      e.preventDefault();
      e.stopPropagation();
    }

    // Highlight drop zone when dragging over it
    ['dragenter', 'dragover'].forEach(eventName => {
      dropzone.addEventListener(eventName, () => {
        dropzone.classList.add('dragover');
      }, false);
    });

    ['dragleave', 'drop'].forEach(eventName => {
      dropzone.addEventListener(eventName, () => {
        dropzone.classList.remove('dragover');
      }, false);
    });

    // Handle dropped files
    dropzone.addEventListener('drop', (e) => {
      const files = Array.from(e.dataTransfer.files);
      if (files.length > 0) {
        handleFiles(files);
      }
    }, false);

    function handleFiles(files) {
      // Filter for CSV files only
      const csvFiles = files.filter(f => f.name.endsWith('.csv'));

      if (csvFiles.length === 0) {
        showStatus('error', 'Please upload CSV files only.');
        return;
      }

      if (csvFiles.length !== files.length) {
        showStatus('error', 'Some files were skipped (only CSV files are accepted).');
        setTimeout(() => status.style.display = 'none', 3000);
      }

      selectedFiles = csvFiles;
      displayFileList();
      uploadFiles();
    }

    function displayFileList() {
      fileList.innerHTML = '<strong>Files to upload:</strong><br>' +
        selectedFiles.map(f => '<div class="file-item">â€¢ ' + f.name + '</div>').join('');
      fileList.classList.add('visible');
    }

    async function uploadFiles() {
      showStatus('processing', 'Reading ' + selectedFiles.length + ' file(s)...');

      try {
        const payload = [];
        for (const file of selectedFiles) {
          const text = await file.text();
          payload.push({ name: file.name, text: text });
        }

        showStatus('processing', 'Uploading to Google Sheets...');

        // Send to server
        google.script.run
          .withSuccessHandler(onSuccess)
          .withFailureHandler(onError)
          .appendUploadedFecCsvBatch(payload);
      } catch (err) {
        showStatus('error', 'Failed to read files: ' + err.message);
      }
    }

    function onSuccess(message) {
      showStatus('success', message);
      setTimeout(() => {
        google.script.host.close();
      }, 2500);
    }

    function onError(error) {
      showStatus('error', 'Error: ' + error.message);
    }

    function showStatus(type, message) {
      status.className = type;
      status.textContent = message;
    }
  </script>
</body>
</html>
  `;
}

// Accepts [{name, text}] and appends mapped rows into FEC_Exports
function appendUploadedFecCsvBatch(files) {
  const ss = SpreadsheetApp.getActive();
  const out = getOrCreateSheet_('FEC_Exports');
  ensureHeaderExists_(out);

  // Pull options and fed map once
  const optsForDecay = readOptions_();
  const annualLoss   = optsForDecay.percentLossPerYear; // 0..1
  const fedMap       = getFedWeightsMap_();

  let totalRows = 0;
  let fileCount = 0;

  files.forEach(file => {
    try {
      const rows = Utilities.parseCsv(String(file.text || ''), ',');
      if (!rows || !rows.length) return;

      const header = rows[0].map(h => String(h || '').trim().toLowerCase());
      const idx = {
        candidateName: findCol_(header, ['candidate_name']),
        committeeName: findCol_(header, ['committee_name']),
        donorFirst:    findCol_(header, ['contributor_first_name']),
        donorLast:     findCol_(header, ['contributor_last_name']),
        donorFull:     findCol_(header, ['contributor_name']),
        addr1:         findCol_(header, ['contributor_street_1']),
        addr2:         findCol_(header, ['contributor_street_2']),
        city:          findCol_(header, ['contributor_city']),
        state:         findCol_(header, ['contributor_state']),
        zip:           findCol_(header, ['contributor_zip']),
        amount:        findCol_(header, ['contribution_receipt_amount']),
        receipt:       findCol_(header, ['contribution_receipt_date']),
        occupation:    findCol_(header, ['contributor_occupation']),
        employer:      findCol_(header, ['contributor_employer'])
      };

      const mapped = [];
      for (let i = 1; i < rows.length; i++) {
        const r = rows[i];

        const recipient = safeGet_(r, idx.candidateName) || safeGet_(r, idx.committeeName);

        let donorFirst = capName_(safeGet_(r, idx.donorFirst));
        let donorLast  = capName_(safeGet_(r, idx.donorLast));
        if ((!donorFirst || !donorLast) && idx.donorFull !== -1) {
          const parts = String(safeGet_(r, idx.donorFull)).split(/\s+/).filter(Boolean);
          if (!donorFirst && parts.length) donorFirst = capName_(parts[0]);
          if (!donorLast && parts.length > 1) donorLast = capName_(parts.slice(1).join(' '));
        }

        const amountStr = safeGet_(r, idx.amount);
        const amountNum = parseAmount_(amountStr);

        const receiptStr = safeGet_(r, idx.receipt);
        const decay      = computeAgeDecay_(receiptStr, annualLoss);

        const fedWeight  = lookupFedWeight_(fedMap, recipient); // default 1 if missing
        const weighted   = Number.isFinite(amountNum) ? roundCents_(amountNum * fedWeight * decay) : '';

        if (!recipient && !donorFirst && !donorLast && !amountStr) continue;

        const rawState = safeGet_(r, idx.state);
        const rawZip = safeGet_(r, idx.zip);
        const validState = getValidState_(rawState, rawZip);

        mapped.push([
          recipient,                           // Recipient
          donorFirst,                          // DonorFirst
          donorLast,                           // DonorLast
          safeGet_(r, idx.addr1),              // Address1
          safeGet_(r, idx.addr2),              // Address2
          safeGet_(r, idx.city),               // City
          validState,                          // State (validated or from ZIP lookup)
          normalizeZip_(rawZip),               // Zip
          amountStr,                           // Amount
          weighted,                            // WeightedAmount
          receiptStr,                          // ReceiptDate
          safeGet_(r, idx.occupation),         // Occupation
          safeGet_(r, idx.employer),           // Employer
          ''                                   // DonationID
        ]);
      }

      if (mapped.length) {
        const start = out.getLastRow() + 1;
        out.getRange(start, 1, mapped.length, OUTPUT_HEADER.length).setValues(mapped);

        const idCol = 14; // N
        const nextId = getNextDonationId_(out, idCol);
        const ids = Array.from({ length: mapped.length }, (_, i) => [nextId + i]);
        out.getRange(start, idCol, mapped.length, 1).setValues(ids);

        totalRows += mapped.length;
      }
      fileCount++;
    } catch (e) {
      throw new Error('Failed on file: ' + (file.name || '(unnamed)') + ' - ' + e.message);
    }
  });

  return 'Added ' + totalRows + ' row(s) from ' + fileCount + ' file(s) into FEC_Exports';
}


/** Sheet setup **/
function resetOutputSheet_(ss, name) {
  const existing = ss.getSheetByName(name);
  if (existing) ss.deleteSheet(existing);
  const sh = ss.insertSheet(name);

  const neededCols = OUTPUT_HEADER.length;
  if (sh.getMaxColumns() < neededCols) {
    sh.insertColumnsAfter(sh.getMaxColumns(), neededCols - sh.getMaxColumns());
  } else if (sh.getMaxColumns() > neededCols) {
    sh.deleteColumns(neededCols + 1, sh.getMaxColumns() - neededCols);
  }

  sh.getRange(1, 1, 1, neededCols).setValues([OUTPUT_HEADER]);

  sh.getRange('A:N').setNumberFormat('@');
  sh.getRange('I:I').setNumberFormat('0.00');
  sh.getRange('J:J').setNumberFormat('0.00');
  sh.getRange('K:K').setNumberFormat('m/d/yyyy');
  sh.getRange('N:N').setNumberFormat('0');

  sh.setFrozenRows(1);
  return sh;
}

/** Helpers **/
function readRows_(ss, name, startRow, startCol, numCols) {
  const sh = ss.getSheetByName(name);
  if (!sh) return [];
  const n = Math.max(sh.getLastRow() - (startRow - 1), 0);
  return n ? sh.getRange(startRow, startCol, n, numCols).getValues() : [];
}

function getNextDonationId_(sheet, colIndex) {
  const lastRow = sheet.getLastRow();
  if (lastRow < 2) return 1;
  const vals = sheet.getRange(2, colIndex, lastRow - 1, 1).getValues().flat();
  let maxId = 0;
  for (const v of vals) {
    const n = Number(v);
    if (Number.isFinite(n) && n > maxId) maxId = n;
  }
  return maxId + 1;
}

function buildExportUrl_(params) {
  const qs = Object.keys(params)
    .filter(k => params[k] != null && params[k] !== '')
    .map(k => encodeURIComponent(k) + '=' + encodeURIComponent(String(params[k])))
    .join('&');
  return `${EXPORT_BASE}?${qs}`;
}

function readOptions_() {
  const sh = SpreadsheetApp.getActive().getSheetByName(OPTIONS_SHEET);
  if (!sh) return {...DEFAULTS, percentLossPerYear: 0};

  // Existing A2:E2
  const row = sh.getRange(2, 1, 1, 5).getValues()[0] || [];
  const [minAmt, maxAmt, minDate, maxDate, types] = row;

  // New H2 for annual percent loss
  let annualLossCell = '';
  try {
    annualLossCell = sh.getRange(2, 8).getValue(); // H2
  } catch (e) {
    annualLossCell = '';
  }

  const asInt = (v, d) => { const n = parseInt(v, 10); return Number.isFinite(n) ? n : d; };
  const asStr = (v, d) => { const s = String(v || '').trim(); return s || d; };

  const opts = {
    minAmount: asInt(minAmt, DEFAULTS.minAmount),
    maxAmount: asInt(maxAmt, DEFAULTS.maxAmount),
    minimalDate: asStr(minDate, DEFAULTS.minimalDate),
    maximalDate: String(maxDate || '').trim(),
    contributionTypes: asStr(types, DEFAULTS.contributionTypes),
    percentLossPerYear: normalizeAnnualLossRate_(annualLossCell) // 0..1
  };

  if (opts.maxAmount < opts.minAmount) { const t = opts.minAmount; opts.minAmount = opts.maxAmount; opts.maxAmount = t; }
  if (!/^\d{4}-\d{2}-\d{2}$/.test(opts.minimalDate)) opts.minimalDate = DEFAULTS.minimalDate;
  if (opts.maximalDate && !/^\d{4}-\d{2}-\d{2}$/.test(opts.maximalDate)) opts.maximalDate = '';
  return opts;
}

function toKrefDate_(iso) {
  if (!iso) return '';
  const m = String(iso).match(/^(\d{4})-(\d{2})-(\d{2})$/);
  if (!m) return '';
  const [, y, mm, dd] = m;
  return `${mm}/${dd}/${y} 00:00:00`;
}

function httpGetText_(url) {
  try {
    const res = UrlFetchApp.fetch(url, {
      method: 'get',
      headers: {
        'User-Agent': USER_AGENT,
        'Accept': 'text/csv,text/plain,*/*',
        'Accept-Language': 'en-US,en;q=0.9'
      },
      muteHttpExceptions: true,
      validateHttpsCertificates: true
    });
    const code = res.getResponseCode();
    if (code < 200 || code >= 300) {
      const body = res.getContentText().substring(0, 200);
      throw new Error(`HTTP ${code} for ${url}\nResponse: ${body}`);
    }
    return res.getContentText();
  } catch (e) {
    // Log full error details for debugging
    Logger.log(`httpGetText_ failed: ${e.toString()}`);
    Logger.log(`URL: ${url}`);
    throw new Error(`Network error: ${e.message}`);
  }
}

// exact match first, then contains match
function findCol_(lowerHeader, names) {
  for (const n of names) {
    const i = lowerHeader.findIndex(h => h === n);
    if (i !== -1) return i;
  }
  for (let i = 0; i < lowerHeader.length; i++) {
    if (names.some(n => lowerHeader[i].includes(n))) return i;
  }
  return -1;
}

function safeGet_(row, idx) {
  if (idx === -1) return '';
  const v = row[idx];
  return v == null ? '' : String(v).trim();
}

function capName_(s) {
  const t = String(s || '').toLowerCase();
  return t.replace(/(^|['\s-])([a-z])/g, (m, p1, p2) => p1 + p2.toUpperCase());
}

function parseAmount_(s) {
  const n = Number(String(s || '').replace(/[^\d.-]/g, ''));
  return Number.isFinite(n) ? n : NaN;
}

function toNumber_(v, fallback) {
  if (v === null || v === undefined) return fallback;
  const s = String(v).trim();
  if (s === '') return fallback;
  const n = Number(s);
  return Number.isFinite(n) ? n : fallback;
}

function roundCents_(n) {
  return Math.round(n * 100) / 100;
}

function showProgress_(current, total, label) {
  const pct = Math.floor((current / Math.max(total, 1)) * 100);
  SpreadsheetApp.getActive().toast(`${pct}% â€¢ ${label}`, 'KREF export', 5);
}

// Keep only the first 5 digits. Preserve leading zeros by returning a string.
function normalizeZip_(s) {
  const digits = String(s || '').replace(/\D+/g, '');
  if (digits.length >= 5) return digits.slice(0, 5);
  if (digits.length > 0) return digits.padStart(5, '0');
  return '';
}
// Create sheet if missing and return it
function getOrCreateSheet_(name) {
  const ss = SpreadsheetApp.getActive();
  return ss.getSheetByName(name) || ss.insertSheet(name);
}

// Ensure header exists and matches OUTPUT_HEADER exactly
function ensureHeaderExists_(sheet) {
  const neededCols = OUTPUT_HEADER.length;

  // Ensure the sheet has exactly neededCols columns
  const maxCols = sheet.getMaxColumns();
  if (maxCols < neededCols) {
    sheet.insertColumnsAfter(maxCols, neededCols - maxCols);
  } else if (maxCols > neededCols) {
    sheet.deleteColumns(neededCols + 1, maxCols - neededCols);
  }

  // Write or refresh header row
  sheet.getRange(1, 1, 1, neededCols).setValues([OUTPUT_HEADER]);

  // Basic formats
  sheet.getRange('A:N').setNumberFormat('@');
  sheet.getRange('I:I').setNumberFormat('0.00');      // Amount
  sheet.getRange('J:J').setNumberFormat('0.00');      // WeightedAmount
  sheet.getRange('K:K').setNumberFormat('m/d/yyyy');  // ReceiptDate
  sheet.getRange('N:N').setNumberFormat('0');         // DonationID
  sheet.setFrozenRows(1);
}
// Parse a flexible date string like "m/d/yyyy", "yyyy-mm-dd", or with time
function parseDateFlexible_(s) {
  const raw = String(s || '').trim();
  if (!raw) return null;

  // Try explicit m/d/yyyy first
  const md = raw.match(/^(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{2,4})(?:.*)?$/);
  if (md) {
    const m = parseInt(md[1], 10);
    const d = parseInt(md[2], 10);
    let y = parseInt(md[3], 10);
    if (y < 100) y += 2000;
    const dt = new Date(y, m - 1, d);
    return Number.isNaN(dt.getTime()) ? null : dt;
  }

  // Fallback to Date parser
  const dt = new Date(raw);
  return Number.isNaN(dt.getTime()) ? null : dt;
}

// Years between date and today, in fractional years
function yearsSince_(dateObj) {
  if (!(dateObj instanceof Date)) return 0;
  const now = new Date();
  const ms = now.getTime() - dateObj.getTime();
  if (ms <= 0) return 0;
  return ms / (365.25 * 24 * 60 * 60 * 1000);
}

// Convert a user percent to a 0..1 rate. Accepts "20" or "0.2"
function normalizeAnnualLossRate_(v) {
  let n = Number(String(v || '').trim());
  if (!Number.isFinite(n) || n < 0) n = 0;
  // If user enters 20, treat as 20%
  if (n > 1) n = n / 100;
  // Clamp to [0, 0.999] to avoid hitting zero for old gifts
  if (n >= 0.999) n = 0.999;
  return n;
}

// Compute time-decay factor given receipt date and annual loss rate
function computeAgeDecay_(receiptStr, annualLossInput) {
  const rate = normalizeAnnualLossRate_(annualLossInput); // 0..1
  if (rate <= 0) return 1;
  const d = parseDateFlexible_(receiptStr);
  const yrs = yearsSince_(d);
  // Decay as (1 - rate) ^ years
  return Math.pow(1 - rate, yrs);
}

// Build a map from "FED Donations" sheet: { normalizedName -> weight }
function getFedWeightsMap_() {
  const ss = SpreadsheetApp.getActive();
  const sh = ss.getSheetByName('FED Donations');
  const map = Object.create(null);
  if (!sh) return map;

  const lastRow = sh.getLastRow();
  if (lastRow < 2) return map;

  // Read cols A and B, rows 2..last
  const values = sh.getRange(2, 1, lastRow - 1, 2).getValues();
  for (const [name, score] of values) {
    const key = String(name || '').trim().toLowerCase();
    if (!key) continue;
    const num = Number(String(score || '').trim());
    map[key] = Number.isFinite(num) && num > 0 ? num : 1;
  }
  return map;
}

// Case-insensitive lookup for a recipient name in the fed map
function lookupFedWeight_(fedMap, recipient) {
  const key = String(recipient || '').trim().toLowerCase();
  if (!key) return 1;
  return fedMap[key] || 1;
}

// Valid US state abbreviations (50 states + DC + territories)
const VALID_US_STATES_ = new Set([
  'AL', 'AK', 'AZ', 'AR', 'CA', 'CO', 'CT', 'DE', 'FL', 'GA',
  'HI', 'ID', 'IL', 'IN', 'IA', 'KS', 'KY', 'LA', 'ME', 'MD',
  'MA', 'MI', 'MN', 'MS', 'MO', 'MT', 'NE', 'NV', 'NH', 'NJ',
  'NM', 'NY', 'NC', 'ND', 'OH', 'OK', 'OR', 'PA', 'RI', 'SC',
  'SD', 'TN', 'TX', 'UT', 'VT', 'VA', 'WA', 'WV', 'WI', 'WY',
  'DC', 'PR', 'VI', 'GU', 'AS', 'MP'
]);

// ZIP prefix to State lookup (covers most common ZIP ranges)
const ZIP_TO_STATE_ = {
  '900': 'CA', '901': 'CA', '902': 'CA', '903': 'CA', '904': 'CA', '905': 'CA', '906': 'CA', '907': 'CA', '908': 'CA',
  '910': 'CA', '911': 'CA', '912': 'CA', '913': 'CA', '914': 'CA', '915': 'CA', '916': 'CA', '917': 'CA', '918': 'CA',
  '919': 'CA', '920': 'CA', '921': 'CA', '922': 'CA', '923': 'CA', '924': 'CA', '925': 'CA', '926': 'CA', '927': 'CA',
  '928': 'CA', '930': 'CA', '931': 'CA', '932': 'CA', '933': 'CA', '934': 'CA', '935': 'CA', '936': 'CA', '937': 'CA',
  '938': 'CA', '939': 'CA', '940': 'CA', '941': 'CA', '942': 'CA', '943': 'CA', '944': 'CA', '945': 'CA', '946': 'CA',
  '947': 'CA', '948': 'CA', '949': 'CA', '950': 'CA', '951': 'CA', '952': 'CA', '953': 'CA', '954': 'CA', '955': 'CA',
  '956': 'CA', '957': 'CA', '958': 'CA', '959': 'CA', '960': 'CA', '961': 'CA',
  '100': 'NY', '101': 'NY', '102': 'NY', '103': 'NY', '104': 'NY', '105': 'NY', '106': 'NY', '107': 'NY', '108': 'NY',
  '109': 'NY', '110': 'NY', '111': 'NY', '112': 'NY', '113': 'NY', '114': 'NY', '115': 'NY', '116': 'NY', '117': 'NY',
  '118': 'NY', '119': 'NY', '120': 'NY', '121': 'NY', '122': 'NY', '123': 'NY', '124': 'NY', '125': 'NY', '126': 'NY',
  '127': 'NY', '128': 'NY', '129': 'NY', '130': 'NY', '131': 'NY', '132': 'NY', '133': 'NY', '134': 'NY', '135': 'NY',
  '136': 'NY', '137': 'NY', '138': 'NY', '139': 'NY', '140': 'NY', '141': 'NY', '142': 'NY', '143': 'NY', '144': 'NY',
  '145': 'NY', '146': 'NY', '147': 'NY', '148': 'NY', '149': 'NY',
  '600': 'IL', '601': 'IL', '602': 'IL', '603': 'IL', '604': 'IL', '605': 'IL', '606': 'IL', '607': 'IL', '608': 'IL',
  '609': 'IL', '610': 'IL', '611': 'IL', '612': 'IL', '613': 'IL', '614': 'IL', '615': 'IL', '616': 'IL', '617': 'IL',
  '618': 'IL', '619': 'IL', '620': 'IL', '622': 'IL', '623': 'IL', '624': 'IL', '625': 'IL', '626': 'IL', '627': 'IL',
  '628': 'IL', '629': 'IL',
  '700': 'LA', '701': 'LA', '702': 'LA', '703': 'LA', '704': 'LA', '705': 'LA', '706': 'LA', '707': 'LA', '708': 'LA',
  '710': 'LA', '711': 'LA', '712': 'LA', '713': 'LA', '714': 'LA',
  '750': 'TX', '751': 'TX', '752': 'TX', '753': 'TX', '754': 'TX', '755': 'TX', '756': 'TX', '757': 'TX', '758': 'TX',
  '759': 'TX', '760': 'TX', '761': 'TX', '762': 'TX', '763': 'TX', '764': 'TX', '765': 'TX', '766': 'TX', '767': 'TX',
  '768': 'TX', '769': 'TX', '770': 'TX', '771': 'TX', '772': 'TX', '773': 'TX', '774': 'TX', '775': 'TX', '776': 'TX',
  '777': 'TX', '778': 'TX', '779': 'TX', '780': 'TX', '781': 'TX', '782': 'TX', '783': 'TX', '784': 'TX', '785': 'TX',
  '786': 'TX', '787': 'TX', '788': 'TX', '789': 'TX', '790': 'TX', '791': 'TX', '792': 'TX', '793': 'TX', '794': 'TX',
  '795': 'TX', '796': 'TX', '797': 'TX', '798': 'TX', '799': 'TX',
  '300': 'FL', '301': 'FL', '302': 'FL', '303': 'FL', '304': 'FL', '305': 'FL', '306': 'FL', '307': 'FL', '308': 'FL',
  '309': 'FL', '310': 'FL', '311': 'FL', '312': 'FL', '313': 'FL', '314': 'FL', '315': 'FL', '316': 'FL', '317': 'FL',
  '318': 'FL', '319': 'FL', '320': 'FL', '321': 'FL', '322': 'FL', '323': 'FL', '324': 'FL', '325': 'FL', '326': 'FL',
  '327': 'FL', '328': 'FL', '329': 'FL', '330': 'FL', '331': 'FL', '332': 'FL', '333': 'FL', '334': 'FL', '335': 'FL',
  '336': 'FL', '337': 'FL', '338': 'FL', '339': 'FL',
  '150': 'PA', '151': 'PA', '152': 'PA', '153': 'PA', '154': 'PA', '155': 'PA', '156': 'PA', '157': 'PA', '158': 'PA',
  '159': 'PA', '160': 'PA', '161': 'PA', '162': 'PA', '163': 'PA', '164': 'PA', '165': 'PA', '166': 'PA', '167': 'PA',
  '168': 'PA', '169': 'PA', '170': 'PA', '171': 'PA', '172': 'PA', '173': 'PA', '174': 'PA', '175': 'PA', '176': 'PA',
  '177': 'PA', '178': 'PA', '179': 'PA', '180': 'PA', '181': 'PA', '182': 'PA', '183': 'PA', '184': 'PA', '185': 'PA',
  '186': 'PA', '187': 'PA', '188': 'PA', '189': 'PA', '190': 'PA', '191': 'PA', '192': 'PA', '193': 'PA', '194': 'PA',
  '195': 'PA', '196': 'PA'
};

// Lookup state from ZIP code prefix
function lookupStateFromZip_(zipCode) {
  if (!zipCode) return '';
  const zipStr = String(zipCode).trim().substring(0, 3);
  return ZIP_TO_STATE_[zipStr] || '';
}

// Check if value is broken/missing or not a valid US state
function isBrokenState_(val) {
  if (!val) return true;
  const s = String(val).trim().toUpperCase();
  // Check if empty, NA, or other broken values
  if (s === '' || s === 'NA' || s === 'N/A' || s === 'UNKNOWN' || s === 'NULL') return true;
  // Also check if it's not a valid US state
  return !VALID_US_STATES_.has(s);
}

// Get valid state - either from the value itself or from ZIP lookup
function getValidState_(stateVal, zipVal) {
  if (!isBrokenState_(stateVal)) {
    // State is valid, return it normalized to uppercase
    return String(stateVal).trim().toUpperCase();
  }
  // State is broken/invalid, try ZIP lookup
  return lookupStateFromZip_(zipVal);
}
